<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Express-guide by sofish</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Express-guide</h1>
          <h2>对英文版 ExpressJS 的一个翻译</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/sofish/express-guide/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/sofish/express-guide/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/sofish/express-guide" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>Express 指南</h1>

<p>这是对 <a href="http://expressjs.com/guide.html">express.js guide</a> 的一个翻译。翻译人：<a href="http://sofish.de">Sofish Lin</a>（<a href="http://twitter.com/sofish">twitter</a>）。</p>

<p>翻译此文档的目的是学习 Express，因为翻译意味着一种责任，因此边看 Express 源代码边翻。在容易混淆的地方都加上了译注。给自己做一个记录保存下来，也给有需要的人一份参考。当然，由于个人水平的原因，并不能最恰当地传达作者的幽默，也少不了错误，还请各位有看到的同学多多指正。</p>

<p>如有任何问题，请直接给我提 issue、pull request 或者在 twitter at-at 我。</p>

<hr><h3>安装</h3>

<div class="highlight"><pre><span class="nv">$ </span>npm install express
</pre></div>

<p>或者在任何地方使用可执行的 <code>express(1)</code> 安装： </p>

<div class="highlight"><pre><span class="se">\#</span> 译注：强烈建议这种方式
<span class="nv">$ </span>npm install -g express
</pre></div>

<h2>快速上手</h2>

<p>最快上手 express 的方法是利用可执行的 <code>express(1)</code> 来生成一个应用，如下所示：</p>

<p>创建一个 app：</p>

<div class="highlight"><pre><span class="nv">$ </span>npm install -g express
<span class="nv">$ </span>express /tmp/foo <span class="o">&amp;&amp;</span> <span class="nb">cd</span> /tmp/foo
</pre></div>

<p>安装依赖包：</p>

<div class="highlight"><pre><span class="nv">$ </span>npm install -d
</pre></div>

<p>启动服务器:</p>

<div class="highlight"><pre><span class="nv">$ </span>node app.js
</pre></div>

<h3>创建一个服务器</h3>

<p>要创建一个 <code>express.HTTPServer</code> 实例，只需调用 <code>createServer()</code> 方法。 通用这个应用实例，我们可以定义基于 HTTP 动作（HTTP Verbs）的路由，以 <code>app.get()</code> 为例：</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">).</span><span class="nx">createServer</span><span class="p">();</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'hello world'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</pre></div>

<h3>创建一个 HTTPS 服务器</h3>

<p>如上述初始化一个 <code>express.HTTPSServer</code> 实例。然后我们给它传一个配置对象，接受 <code>key</code>、<code>cert</code> 和其他在 <a href="http://nodejs.org/docs/v0.3.7/api/https.html#https.createServer">https 文档</a> 所提到的（属性/方法）。</p>

<div class="highlight"><pre> <span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">).</span><span class="nx">createServer</span><span class="p">({</span> <span class="nx">key</span><span class="o">:</span> <span class="p">...</span> <span class="p">});</span>
</pre></div>

<h3>配置</h3>

<p>Express 支持任意环境，如产品阶段（production）和开发阶段（development）。开发者可以使用 <code>configure()</code> 方法来设置当前所需环境。如果 <code>configure()</code> 的调用不包含任何环境名，它将运行于所有环境中所指定的回调。</p>

<p>译注： 像 <em>production</em> / <em>development</em> / <em>stage</em> 这些别名都是可以自已取的，如 <a href="https://github.com/visionmedia/express/blob/master/lib/application.js">application.js</a> 中的 <code>app.configure</code> 所示。实际用法看下面例子。</p>

<p>下面这个例子仅在开发阶段 <code>dumpExceptions</code> (抛错)，并返回堆栈异常。不过在两个环境中我们都使用 <code>methodOverride</code> 和 <code>bodyParser</code>。注意一下 <code>app.router</code> 的使用，它可以（可选）用来加载（mount）程序的路由，另外首次调用 <code>app.get()</code>、<code>app.post()</code> 等也将会加载路由。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">configure</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">methodOverride</span><span class="p">());</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">app</span><span class="p">.</span><span class="nx">router</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">configure</span><span class="p">(</span><span class="s1">'development'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="kr">static</span><span class="p">(</span><span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/public'</span><span class="p">));</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">errorHandler</span><span class="p">({</span> <span class="nx">dumpExceptions</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">showStack</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}));</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">configure</span><span class="p">(</span><span class="s1">'production'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">oneYear</span> <span class="o">=</span> <span class="mi">31557600000</span><span class="p">;</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="kr">static</span><span class="p">(</span><span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/public'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">maxAge</span><span class="o">:</span> <span class="nx">oneYear</span> <span class="p">}));</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">errorHandler</span><span class="p">());</span>
<span class="p">});</span>
</pre></div>

<p>对于相似的环境你可以传递多个环境字符串：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">configure</span><span class="p">(</span><span class="s1">'stage'</span><span class="p">,</span> <span class="s1">'prod'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="c1">// config</span>
<span class="p">});</span>
</pre></div>

<p>对于任何内部设置（<a href="https://twitter.com/sofish/status/219430499725217794">#</a>)，Express 提供了 <code>set(key[, val])</code>、 <code>enable(key)</code> 和 <code>disable(key)</code> 方法:</p>

<p>译注：设置详见：<a href="https://github.com/visionmedia/express/blob/master/lib/application.js">application.js</a> 的 <code>app.set</code>。</p>

<div class="highlight"><pre> <span class="nx">app</span><span class="p">.</span><span class="nx">configure</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'views'</span><span class="p">,</span> <span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/views'</span><span class="p">);</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'views'</span><span class="p">);</span>
    <span class="c1">// =&gt; "/absolute/path/to/views"</span>

    <span class="nx">app</span><span class="p">.</span><span class="nx">enable</span><span class="p">(</span><span class="s1">'some feature'</span><span class="p">);</span>
    <span class="c1">// 等价于：app.set('some feature', true);</span>

    <span class="nx">app</span><span class="p">.</span><span class="nx">disable</span><span class="p">(</span><span class="s1">'some feature'</span><span class="p">);</span>
    <span class="c1">// 等价于：app.set('some feature', false);</span>

    <span class="nx">app</span><span class="p">.</span><span class="nx">enabled</span><span class="p">(</span><span class="s1">'some feature'</span><span class="p">)</span>
    <span class="c1">// =&gt; false</span>
 <span class="p">});</span>
</pre></div>

<p>变更环境我们可以设置 <code>NODE_ENV</code> 环境变量，如：</p>

<div class="highlight"><pre><span class="nv">$ NODE_ENV</span><span class="o">=</span>production node app.js
</pre></div>

<p>这非常重要，因为多数缓存机制只在产品阶段是被打开的。</p>

<h3>设置</h3>

<p>Express 支持下列快捷（out of the box）设置:</p>

<ul>
<li>
<code>basepath</code> 用于 <code>res.redirect()</code> 的应用程序基本路径（base path），显式地处理绑定的应用程序（transparently handling mounted apps.）</li>
<li>
<code>view</code> View 默认的根目录为 <strong>CWD/views</strong>
</li>
<li>
<code>view engine</code> 默认 View 引擎处理（View 文件）并不需要使用后缀</li>
<li>
<code>view cache</code> 启用 View 缓存 (在产品阶段被启用)</li>
<li>
<code>charet</code> 改变编码，默认为 utf-8</li>
<li>
<code>case sensitive routes</code> 路由中区分大小写</li>
<li>
<code>strit routing</code> 启用后（路由中的）结尾 <code>/</code> 将不会被忽略（译注：即 <code>app.get('/sofish')</code> 和 <code>app.get('/sofish/')</code> 将是不一样的）</li>
<li>
<code>json callback</code> 启用 <code>res.send()</code> / <code>res.json()</code> 显式的 jsonp 支持（transparent jsonp support）</li>
</ul><h3>路由</h3>

<p>Express 利用 HTTP 动作提供一套提示性强、有表现力的路由 API。打个比方，如果想要处理某个路径为 <em>/user/12</em> 的账号，我们能像下面这样来定义路由。关联到命名占位符（named placeholders）的值可用 <code>req.params</code> 来访问。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:id'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'user '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>路由是一个在内部被编译为正则的字符串。譬如，当 <em>/user/:id</em> 被编译，一个简化版本的正则表达弄大概如下：</p>

<div class="highlight"><pre><span class="c1">// 修改一下官方的这个字符串</span>
<span class="sr">/\/user\/([^\/]+)\/?/</span>
</pre></div>

<p>正则表达式可以传入应用于复杂的场景。由于通过字面量正则表达式捕获的内容组是匿名的，我们可能直接通过 <code>req.params</code> 来访问它们。因此，我们捕获的第一组内容将是 <code>req.params[0]</code>，同时第二组是紧接着的 <code>req.params[1]</code>。 </p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="sr">/^\/users?(?:\/(\d+)(?:\.\.(\d+))?)?/</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>Curl 针对上述定义路由的请求：</p>

<div class="highlight"><pre><span class="nv">$ </span>curl http://dev:3000/user
<span class="o">[</span>null,null<span class="o">]</span>
<span class="nv">$ </span>curl http://dev:3000/users
<span class="o">[</span>null,null<span class="o">]</span>
<span class="nv">$ </span>curl http://dev:3000/users/1
<span class="o">[</span><span class="s2">"1"</span>,null<span class="o">]</span>
<span class="nv">$ </span>curl http://dev:3000/users/1..15
<span class="o">[</span><span class="s2">"1"</span>,<span class="s2">"15"</span><span class="o">]</span>
</pre></div>

<p>下面是一些路由的实例，关联到他们可能使用到的路径：</p>

<div class="highlight"><pre><span class="s2">"/user/:id"</span>
/user/12

<span class="s2">"/users/:id?"</span>
/users/5
/users

<span class="s2">"/files/*"</span>
/files/jquery.js
/files/javascripts/jquery.js

<span class="s2">"/file/*.*"</span>
/files/jquery.js
/files/javascripts/jquery.js

<span class="s2">"/user/:id/:operation?"</span>
/user/1
/user/1/edit

<span class="s2">"/products.:format"</span>
/products.json
/products.xml

<span class="s2">"/products.:format?"</span>
/products.json
/products.xml
/products

<span class="s2">"/user/:id.:format?"</span>
/user/12
/user/12.json
</pre></div>

<p>举个例子，我们可以使用 <code>POST</code> 发送 json 数据，通过 <code>bodyParser</code> 这个可以解析 json 请求内容（或者其他内容）的中间件来返回数据，并将返回结果存于 <code>req.body</code> 中：</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">.</span><span class="nx">createServer</span><span class="p">();</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</pre></div>

<p>通常我们可以使用一个像 <code>user/:id</code> 这样，没有（命名）限制的“傻瓜”式的占位符。然而比方说，我们要限制用户 id 只能是数字，那么我们可能使用 <code>/user/:id([0-9]+)</code>，这个将仅当占位符是包含至少一位数字时才生效（适配，match）。</p>

<h3>进路控制（Passing Route Control）</h3>

<p>我们可以通过调用第三个参数，<code>next()</code> 函数，来控制下一个适配的路由。如果找不到适配，控制权将会传回给 Connect，同时中间件将会按在 <code>use()</code> 中添加的顺序被依次调用。道理同样适应于多个定义到同一路径的路由，他们将会依次被调用直到其中某个不调用 <code>next()</code> 而决定做出请求响应。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/users/:id?'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// do something</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">next</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/users'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
    <span class="c1">// do something else</span>
<span class="p">});</span>
</pre></div>

<p><code>app.all()</code> 方法只调用一次就可以方便地把同样的逻辑到所有 HTTP 动作。下面我们使用它来从伪数据中提取一个用户，将其赋给 <code>req.user</code>。</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">)</span>
  <span class="p">,</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">.</span><span class="nx">createServer</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">users</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">'tj'</span> <span class="p">}];</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="s1">'/user/:id/:op?'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">){</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">user</span> <span class="o">=</span> <span class="nx">users</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">next</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">next</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'cannot find user '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:id'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'viewing '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:id/edit'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'editing '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">'/user/:id'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'updating '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'*'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="s1">'what???'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span> 
</pre></div>

<h3>中间件</h3>

<p>使用的 <a href="http://github.com/senchalabs/connect">Connect</a> 中间件（属性）通常伴随着你的一个常规 Connect 服务器，被传到 <code>express.createServer()</code> 。如：</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'express'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span>
      <span class="nx">express</span><span class="p">.</span><span class="nx">logger</span><span class="p">()</span>
    <span class="p">,</span> <span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">()</span>
  <span class="p">);</span>
</pre></div>

<p>另外，在 <code>configure()</code> 块内 —— 这个渐进式的宫殿（译注：笑^^，in a progressive manner），我们还可以方便地使用 <code>use()</code> 来添加中间件。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">logger</span><span class="p">({</span> <span class="nx">format</span><span class="o">:</span> <span class="s1">':method :url'</span> <span class="p">}));</span>
</pre></div>

<p>通常，使用 connect 中间件你可能会用到 <code>require('connect')</code>，像这样：</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">connect</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'connect'</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">connect</span><span class="p">.</span><span class="nx">logger</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">connect</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
</pre></div>

<p>这在某种程度上来说有点不爽，所以 express 重导出（re-exports）了这些中间件属性，尽管他们是一样的:</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">logger</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
</pre></div>

<p>中间件的顺序非常重要，当 Connect 收到一个请求，我们传到 <code>createServer()</code> 或者 <code>use()</code> 执行的第一个中间件将附带三个参数，request、response，以及一个回调函数（通常是 <code>next</code>）。当 <code>next()</code> 被调用，将轮到第二个中间件，依此类推。之所以说这是值得注意的，是因为很多中间件彼此依赖，例如 <code>methodOverride()</code> 查询 <code>req.body</code> 方法来检测 HTTP 方法重载，另一方面 <code>bodyParser()</code> 解析请求内容并将其于寄存于 <code>req.body</code>。另一个例子是 cookie 解析和 session 支持，我们必须先 <code>use()</code> <code>cookieParser()</code> 紧接着 <code>session()</code>。</p>

<p>很多 Express 应用都包含这样的一行 <code>app.use(app.router)</code>，这看起来可能有点奇怪，其实它仅仅是一个包含所有定义路由规则，并执行基于现有 URL 请求和 HTTP 方法路由查找的一个中间件功能。Express 允许你决定其位置（to position），不过默认情况下它被放置于底部。通过改变路由的位置，我们可以改变中间件的优先级，譬如我们想把错误报告做为最后的中间件，以便任何传给 <code>next()</code> 的异常都可以通过它来处理；又或者我们希望静态文件服务优先级更低，以允许我们的路由可以监听单个静态文件请求的下载次数，等等。这看起来差不多是这样的：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">logger</span><span class="p">(...));</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">(...));</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">cookieParser</span><span class="p">(...));</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">session</span><span class="p">(...));</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">app</span><span class="p">.</span><span class="nx">router</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="kr">static</span><span class="p">(...));</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">errorHandler</span><span class="p">(...));</span>
</pre></div>

<p>首先我们添加 <code>logger()</code>，它可能包含 node 的 <code>req.end()</code> 方法，提供我们响应时间的数据。接下来请求的内容将会被解析（如果有数据的话），紧接着的是 cookie 解析和 session 支持，同时 <code>req.session</code> 将会在触发 <code>app.router</code> 中的路由时被定义，这时我们并不调用 <code>next()</code>，因此 <code>static()</code> 中间件将不会知道这个请求，如若已经定义了如下一个路由，我们则可以记录各种状态、拒绝下载和消耗下载点数等。</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">downloads</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">app</span><span class="p">.</span><span class="nx">router</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="kr">static</span><span class="p">(</span><span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/public'</span><span class="p">));</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/*'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="nx">downloads</span><span class="p">[</span><span class="nx">file</span><span class="p">]</span> <span class="o">=</span> <span class="nx">downloads</span><span class="p">[</span><span class="nx">file</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">downloads</span><span class="p">[</span><span class="nx">file</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">next</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>

<h3>路由中间件</h3>

<p>路由可以利用路由器中间件，传递一个以上的回调函数（或者数组）到其方法中。这个特性非常有利于限制访问、通过路由下载数据，等等。</p>

<p>通常异步数据检索看起来可能像下例，我们使用 <code>:id</code> 参数，尝试加载一个用户： </p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:id'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">){</span>
  <span class="nx">loadUser</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">user</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Viewing user '</span> <span class="o">+</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>为保证 DRY 原则和提升可读，我们可以把这个逻辑应用于一个中间件内。如下所示，抽象这个逻辑到中间件内将允许你重用它，同时保证了我们路由的简洁。</p>

<div class="highlight"><pre><span class="kd">function</span> <span class="nx">loadUser</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// You would fetch your user from the db</span>
  <span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">users</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">req</span><span class="p">.</span><span class="nx">user</span> <span class="o">=</span> <span class="nx">user</span><span class="p">;</span>
    <span class="nx">next</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">next</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'Failed to load user '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:id'</span><span class="p">,</span> <span class="nx">loadUser</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Viewing user '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>多重路由可以，并按顺序应用到更深一层的逻辑，如限制一个用户账号的访问。下面的例子只允许通过鉴定的用户才可以编辑他（她）的账号。</p>

<div class="highlight"><pre><span class="kd">function</span> <span class="nx">andRestrictToSelf</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">authenticatedUser</span><span class="p">.</span><span class="nx">id</span> <span class="o">==</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">id</span>
    <span class="o">?</span> <span class="nx">next</span><span class="p">()</span>
    <span class="o">:</span> <span class="nx">next</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'Unauthorized'</span><span class="p">));</span>
<span class="p">}</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:id/edit'</span><span class="p">,</span> <span class="nx">loadUser</span><span class="p">,</span> <span class="nx">andRestrictToSelf</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Editing user '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>时刻铭记路由只是简单的函数，如下所示，我们可以定义返回中间件的函数以创建一个更具表现力，更灵活的方案。</p>

<div class="highlight"><pre><span class="kd">function</span> <span class="nx">andRestrictTo</span><span class="p">(</span><span class="nx">role</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">req</span><span class="p">.</span><span class="nx">authenticatedUser</span><span class="p">.</span><span class="nx">role</span> <span class="o">==</span> <span class="nx">role</span>
      <span class="o">?</span> <span class="nx">next</span><span class="p">()</span>
      <span class="o">:</span> <span class="nx">next</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'Unauthorized'</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">del</span><span class="p">(</span><span class="s1">'/user/:id'</span><span class="p">,</span> <span class="nx">loadUser</span><span class="p">,</span> <span class="nx">andRestrictTo</span><span class="p">(</span><span class="s1">'admin'</span><span class="p">),</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'Deleted user '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>常用的中间件“堆栈”可以通过一个数组来传递（会被递归应用），这些中间件可以混着、匹配到任何层次（which can be mixed and matched to any degree）。</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="nx">middleware1</span><span class="p">,</span> <span class="nx">middleware2</span><span class="p">]</span>
  <span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="nx">middleware3</span><span class="p">,</span> <span class="nx">middleware4</span><span class="p">]</span>
  <span class="p">,</span> <span class="nx">all</span> <span class="o">=</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">];</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/foo'</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){});</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/bar'</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">middleware3</span><span class="p">,</span> <span class="nx">middleware4</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){});</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){});</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="nx">all</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){});</span>
</pre></div>

<p>对于这个实例的完整代码，请看 <a href="http://github.com/visionmedia/express/blob/master/examples/route-middleware/app.js">route middleware example</a> 这个仓库。</p>

<p>我们可能会有多次想要“跳过”剩余的路由中间件，继续匹配后续的路由。做到这点，我们只需调用 <code>next()</code> 时带上 <code>'route'</code> 字符串 —— <code>next('route')</code>。如果没有余下的路由匹配到请求的 URL，Express 将会返回 <code>404 Not Found</code>。</p>

<h3>HTTP 方法</h3>

<p>至此已接触了好几次 <code>app.get()</code>，除此这外 Express 还提供了其他常见的 HTTP 动作，如 <code>app.post()</code> 、<code>app.del()</code> 等等。</p>

<p>POST 用法的一个常用例子是提交一个表单。下面我们简单地在 html 中把表单的 method 属性设置为 post，控制权将会指派给它下面所定义的路由。</p>

<div class="highlight"><pre><span class="nt">&lt;form</span> <span class="na">method=</span><span class="s">"post"</span> <span class="na">action=</span><span class="s">"/"</span><span class="nt">&gt;</span>
     <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"user[name]"</span> <span class="nt">/&gt;</span>
     <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"user[email]"</span> <span class="nt">/&gt;</span>
     <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"Submit"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>

<p>默认上 Express 并不知道如何处理这个请求的内容，因此我们必须添加 <code>bodyParser</code> 中间件，它将解析 <code>application/x-www-form-urlencoded</code> 和 <code>application/json</code> 请求的内容，并把变量存放于 <code>req.body</code> 中。我们可以像下述示例一样来使用这个中间件：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
</pre></div>

<p>如下，我们的路由将有权访问 <code>req.body.user</code> 对象，当有 name 和 email 被定义时它将包含这两个属性（译注：如果表单发送的内容不为空的话）。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">user</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">redirect</span><span class="p">(</span><span class="s1">'back'</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>当想在一个表单中使用像 PUT 这样的方法，我们可以使用一个命名为 <code>_method</code> 的 hidden <code>input</code>，它可以用以修改 HTTP 方法。为了做这个，我们首先需要 <code>methodOverride</code> 中间件，它必须出现于 <code>bodyParser</code> 后面，以便使用它的 <code>req.body</code>中所包含的表单值。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">methodOverride</span><span class="p">());</span>
</pre></div>

<p>对于这些方法为何不是默认拥有，简单来说只是因为它并不是 Express 所要求完整功能所必须。方法的使用依赖于你的应用，你可能并不需要它们，客户端依然能使用像 PUT 和 DELETE 这样的方法，你可以直接使用它们，因为 <code>methodOverride</code> 为 form 提供了一个非常不错的解决方案。下面将示范如何使用 PUT 这个方法，看起来可能像：</p>

<div class="highlight"><pre><span class="nt">&lt;form</span> <span class="na">method=</span><span class="s">"post"</span> <span class="na">action=</span><span class="s">"/"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">name=</span><span class="s">"_method"</span> <span class="na">value=</span><span class="s">"put"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"user[name]"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"user[email]"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"Submit"</span> <span class="nt">/&gt;</span>    
<span class="nt">&lt;/form&gt;</span>

app.put('/', function(){
    console.log(req.body.user);
    res.redirect('back');
});
</pre></div>

<h3>错误处理</h3>

<p>Express 提供了 <code>app.error()</code> 方法以便接收到的异常在一个路由里抛出，或者传到 <code>next(err)</code> 中。下面这个例子将基于特定的 NotFound 异常处理不同的页面：</p>

<div class="highlight"><pre><span class="kd">function</span> <span class="nx">NotFound</span><span class="p">(</span><span class="nx">msg</span><span class="p">){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'NotFound'</span><span class="p">;</span>
  <span class="nb">Error</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">msg</span><span class="p">);</span>
  <span class="nb">Error</span><span class="p">.</span><span class="nx">captureStackTrace</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">NotFound</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nb">Error</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/404'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nx">NotFound</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/500'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'keyboard cat!'</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>如下述，我们可以多次调用 <code>app.error()</code>。这里我们检测 NotFound 的实例，并显示 404 页面，或者传到 <code>next</code> 错误处理器。值得注意的是这些处理器可以在任何地方定义，因为他们将会在 <code>listen()</code> 的时候被放置于路由处理器下面。它允许在 <code>configure()</code> 块内有定义，以便我们能基于环境用不同的异常处理方式。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="k">instanceof</span> <span class="nx">NotFound</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'404.jade'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>为求简洁（for the simplicity），这里我们假定这个 demo 的所有错误为 500，当然你可以可以选择自己喜欢的。像 node 执行文件系统的系统调用时，你可能会接收到一个带有 ENOENT 的 <code>error.code</code>，意思为 “不存在这样的文件或目录” 的错误，我们可以在错误处理器中使用，或者当有需要时可显示一个指定的页面。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'500.jade'</span><span class="p">,</span> <span class="p">{</span>
     <span class="nx">error</span><span class="o">:</span> <span class="nx">err</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>我们的 app 同样可以利用 Connect 的 <code>errorHandler</code> 中间件来汇报异常。譬如当我们希望在 “开发” 环境输出 <code>stderr</code> 异常时，我们可以使用：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">errorHandler</span><span class="p">({</span> <span class="nx">dumpExceptions</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}));</span>
</pre></div>

<p>同时在开发阶段我们可能需要在花哨的 HTML 页面显示我们传递和抛出的异常，对此我们可以把 <code>showStack</code> 设置为 <code>true</code>。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">errorHandler</span><span class="p">({</span> <span class="nx">showStack</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">dumpExceptions</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}));</span>
</pre></div>

<p><code>errorHandler</code> 中间件还可以在 <code>Accept: application/json</code> 存在的时候返回 json，这对于开发重度依赖客户端 Javascript 的应用非常有用。</p>

<h3>Route 参数预处理</h3>

<p>路由参数预处理，通过隐式数据加载和请求验证，可以大大提升你程序的可读性。打个比方，你通常需要持续地从多个路由获取基本数据。像用 <code>/user/:id</code> 加载一个用户，通常来说我们可能会这样干：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:userId'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">){</span>
  <span class="nx">User</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">userId</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">user</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'user '</span> <span class="o">+</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span> 
</pre></div>

<p>通过预处理，我们的参数可以映射到执行验证、控制(coercion)，甚至从数据库加载数据的回调。如下我们带着参数名调用 <code>app.param()</code> 希望将其映射于某些中间件。如你所见，我们接受代表占位符值的 <code>id</code> 参数。使用这个，我们如常加载用户并处理错误，以及简单地调用 <code>next()</code> 来把控制权交由下一个预处理或者路由处理器。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">param</span><span class="p">(</span><span class="s1">'userId'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">id</span><span class="p">){</span>
  <span class="nx">User</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">user</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">)</span> <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'failed to find user'</span><span class="p">));</span>
    <span class="nx">req</span><span class="p">.</span><span class="nx">user</span> <span class="o">=</span> <span class="nx">user</span><span class="p">;</span>
    <span class="nx">next</span><span class="p">();</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>一旦这样做，上所述将会大大地提升路由的可读性，并且允许我们轻松地在整个程序中共享逻辑：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/user/:userId'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">'user '</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<h3>View 处理</h3>

<p>View 文件件使用 &lt;name&gt;.&lt;engine&gt; 这样的格式，其中 &lt;engine&gt; 是被 <code>require</code> 进来模块的名。例如 <code>layout.ejs</code> 将告诉 view 系统去 <code>require('ejs')</code>，被加载的模块必须(导出) <code>exports.compile(str, options)</code> 方法，并返回一个 Function 来适应 Express。<code>app.register()</code> 可用以改变这种默认行为，将文件扩展名映射到特定的引擎。譬如 “foo.html” 可以由 ejs 来处理。</p>

<p>下面这个例子使用 <a href="http://github.com/visionmedia/jade">Jade</a> 来处理 index.html。因为我们并未使用 <code>layout: false</code>，index.jade 处理后的内容将会被传入到 layout.jade 中一个名为 body 的本地变量。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'index.jade'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">title</span><span class="o">:</span> <span class="s1">'My Site'</span> <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>新的 <code>view engine</code> 设置允许我们指定默认的模板引擎，例如当我们使用 jade 时可以这样设置：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'view engine'</span><span class="p">,</span> <span class="s1">'jade'</span><span class="p">);</span>
</pre></div>

<p>允许我们这样处理：</p>

<pre><code>res.render('index');
</code></pre>

<p>对应于：</p>

<div class="highlight"><pre><span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'index.jade'</span><span class="p">);</span>
</pre></div>

<p>当 <code>view engine</code> 被设定，扩展名实属可选，但我们依然可以混着匹配模板引擎：</p>

<div class="highlight"><pre><span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'another-page.ejs'</span><span class="p">);</span>
</pre></div>

<p>Express 同时还提供了 <code>view options</code> 设置，这将应用于一个 view 每次被渲染的时候，譬如你不希望使用 layouts  的时候可能会这样做：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'view options'</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">layout</span><span class="o">:</span> <span class="kc">false</span>
<span class="p">});</span>
</pre></div>

<p>在需要的时候，这可以在 <code>res.render()</code> 调用的内部进行重载：</p>

<div class="highlight"><pre><span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'myview.ejs'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">layout</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
</pre></div>

<p>当有需要变更一个 layout，我们通常需要再指定一个路径。譬如当我们已经把 <code>view engine</code> 设置为 jade，并且这个文件命名为 ./views/mylayout.jade，我们可以这样简单地进行传参：</p>

<div class="highlight"><pre><span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'page'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">layout</span><span class="o">:</span> <span class="s1">'mylayout'</span> <span class="p">});</span>
</pre></div>

<p>否则（译注：没有把 <code>view engine</code> 设置为 jade 或者其他的引擎时），我们必须指定一个扩展名：</p>

<div class="highlight"><pre><span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'page'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">layout</span><span class="o">:</span> <span class="s1">'mylayout.jade'</span> <span class="p">});</span>
</pre></div>

<p>它们同样可以是绝对路径：</p>

<div class="highlight"><pre><span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'page'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">layout</span><span class="o">:</span> <span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">'/../../mylayout.jade'</span> <span class="p">});</span>
</pre></div>

<p>对于这点有一个不错的例子 —— 自定义 ejs 的起始和闭合标签：</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'view options'</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">open</span><span class="o">:</span> <span class="s1">'{{'</span><span class="p">,</span>
    <span class="nx">close</span><span class="o">:</span> <span class="s1">'}}'</span>
<span class="p">})</span>
</pre></div>

<h3>View 部件</h3>

<p>Express 的 view 系统内置了部件（partials） 和集合器（collections）的支持，相当于用一个 “迷你” 的 view 替换一个文档碎片（document fragment）。示例，在一个 view 中重复渲染来显示评论，我们可以使用部件集：</p>

<div class="highlight"><pre><span class="nx">partial</span><span class="p">(</span><span class="s1">'comment'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">collection</span><span class="o">:</span> <span class="nx">comments</span> <span class="p">});</span>
</pre></div>

<p>如果并不需要其他选项或者本地变量，我们可以省略整个对象，简单地传进一个数组，这与上述是等价的：</p>

<div class="highlight"><pre><span class="nx">partial</span><span class="p">(</span><span class="s1">'comment'</span><span class="p">,</span> <span class="nx">comments</span><span class="p">);</span>
</pre></div>

<p>在使用中，部件集无偿地提供了一些 “神奇” 本地变量的支持：</p>

<ul>
<li>
<em>firstInCollection</em>  <code>true</code>，当它是第一个对象的时候</li>
<li>
<em>indexInCollection</em>  在集合器对象中的索引</li>
<li>
<em>lastInCollection</em>  <code>true</code>，当它是最后一个对象的时候</li>
<li>
<em>collectionLength</em>  集合器对象的长度</li>
</ul><p>本地变量的传递（生成）具备更高的优先级，同时，传到父级 view 的本地变量对于子级 view 同样适应。例如当我们用 <code>partial('blog/post', post)</code> 来渲染一个博客文章，它将会生成一个 <code>post</code> 本地变量，在调用这个函数的 view 中存在本地变量 <code>user</code>，它将同样对 <code>blog/post</code> 有效。（译注：这里 partial 比较像 php 中的 include 方法）。</p>

<p><strong>注意:</strong> 请谨慎使用部件集合器，渲染一个长度为 100 的部件集合数组相当于我们需要处理 100 个 view。对于简单的集合，最好重复内置，而非使用部件集合器以避免开销过大。</p>

<h3>View 查找</h3>

<p>View 查找相对于父级 view （路径）执行，如我们有一个 view 页面叫作 views/user/list.jade，并且在其内部写有 <code>partial('edit')</code> 则它会尝试加载 views/user/edit.jade，同理 <code>partial('../messages')</code> 将会加载 views/messages.jade。</p>

<p>View 系统还支持模板索引，允许你使用一个与 view 同名的目录。例如在一个路由中，<code>res.render('users')</code> 得到的非 views/users.jade 即 views/users/index.jade。（译注：先处理 &lt;path&gt;.&lt;engine&gt; 的情况，再处理 &lt;path&gt;/&lt;index.&lt;engine&gt; 的情况，详情可见 <a href="https://github.com/visionmedia/express/blob/master/lib/view.js">view.js</a>。）</p>

<p>当使用上述 view 索引，我们在与 view 同一个目录下，使用 <code>partial('users')</code> 中引用 views/users/index.jade，与此同时 view 系统会尝试索引 <code>../users/index</code>，而无须我们调用 <code>partial('users')</code>。</p>

<h3>Template Engines</h3>

<p>下列为 Express 最常用的模板引擎:</p>

<ul>
<li>
<a href="http://github.com/visionmedia/haml.js">Haml</a> haml 实现</li>
<li>
<a href="http://jade-lang.com">Jade</a> haml.js 继位者</li>
<li>
<a href="http://github.com/visionmedia/ejs">EJS</a> 嵌入式 JavaScript</li>
<li>
<a href="http://github.com/mauricemach/coffeekup">CoffeeKup</a> 基于 CoffeeScript 的模板</li>
<li>
<a href="https://github.com/kof/node-jqtpl">jQuery Templates</a> </li>
</ul><h3>Session 支持</h3>

<p>Session 支持可以通过使用 Connect 的 session 中间件来获得，为此通常我们同时需要在其前加上 <code>cookieParser</code> 中间件，它将解析和存储 cookie 数据于 <code>req.cookies</code> 中。</p>

<div class="highlight"><pre><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">cookieParser</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">session</span><span class="p">({</span> <span class="nx">secret</span><span class="o">:</span> <span class="s2">"keyboard cat"</span> <span class="p">}));</span>
</pre></div>

<p>默认情况下 session 中间件使用 Connect 内置的内存存储，然而还有其他多种实现方式。如 <a href="http://github.com/visionmedia/connect-redis">connect-redis</a> 提供了一种 <a href="http://code.google.com/p/redis/">Redis</a> 的 session 存储，它这可像下面这样被使用：</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">RedisStore</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'connect-redis'</span><span class="p">)(</span><span class="nx">express</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">cookieParser</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">session</span><span class="p">({</span> <span class="nx">secret</span><span class="o">:</span> <span class="s2">"keyboard cat"</span><span class="p">,</span> <span class="nx">store</span><span class="o">:</span> <span class="k">new</span> <span class="nx">RedisStore</span> <span class="p">}));</span>
</pre></div>

<p>至此，<code>req.session</code> 和 <code>req.sessionStore</code> 属性将可以被所有路由和后继的中间件使用。在 <code>req.session</code> 上的所有属性都会在一个响应中被自动保存下来，譬如当我们想要添加数据到购物车： </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">RedisStore</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'connect-redis'</span><span class="p">)(</span><span class="nx">express</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">cookieParser</span><span class="p">());</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">session</span><span class="p">({</span> <span class="nx">secret</span><span class="o">:</span> <span class="s2">"keyboard cat"</span><span class="p">,</span> <span class="nx">store</span><span class="o">:</span> <span class="k">new</span> <span class="nx">RedisStore</span> <span class="p">}));</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">'/add-to-cart'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="c1">// 我们可能通过一个表单 POST 出多个 item</span>
  <span class="c1">// (在些使用 bodyParser() 中间件)</span>
  <span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">items</span><span class="p">;</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">session</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="nx">items</span><span class="p">;</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">redirect</span><span class="p">(</span><span class="s1">'back'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/add-to-cart'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">){</span>
  <span class="c1">// 当返回时，页面 GET /add-to-cart</span>
  <span class="c1">// 我们可以检查 req.session.items &amp;&amp; req.session.items.length</span>
  <span class="c1">// 来打印出提示</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">session</span><span class="p">.</span><span class="nx">items</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">session</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">req</span><span class="p">.</span><span class="nx">notify</span><span class="p">(</span><span class="s1">'info'</span><span class="p">,</span> <span class="s1">'You have %s items in your cart'</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">session</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s1">'shopping-cart'</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>对于 <code>req.session</code> 对旬，它还有像 <code>Session#touch()</code>、<code>Session#destroy()</code>、 <code>Session#regenerate()</code> 等用以维护和操作 session 的方法。更多的详情请看 <a href="http://senchalabs.github.com/connect/middleware-session.html">Connect Session</a> 的文档。</p>

<h3>升级指南</h3>

<p>对于使用 Express 1.x 的同学，如果你有很重要的程序需要升级到 2.x 以获得更好的支持，请看官方非常详细的 <a href="http://expressjs.com/guide.html#migration-guide">迁移指南</a></p>

<hr><p>最后，感谢一下自己，又长进了。读到这里的你，如果感觉它对你有帮助，请同时分享给你有需要的朋友吧～</p>
        </section>

        <footer>
          Express-guide is maintained by <a href="https://github.com/sofish">sofish</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>